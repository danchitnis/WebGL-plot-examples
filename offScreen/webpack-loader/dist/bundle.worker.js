/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/comlink/dist/esm/comlink.mjs":
/*!***************************************************!*\
  !*** ./node_modules/comlink/dist/esm/comlink.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createEndpoint\": () => (/* binding */ createEndpoint),\n/* harmony export */   \"expose\": () => (/* binding */ expose),\n/* harmony export */   \"proxy\": () => (/* binding */ proxy),\n/* harmony export */   \"proxyMarker\": () => (/* binding */ proxyMarker),\n/* harmony export */   \"releaseProxy\": () => (/* binding */ releaseProxy),\n/* harmony export */   \"transfer\": () => (/* binding */ transfer),\n/* harmony export */   \"transferHandlers\": () => (/* binding */ transferHandlers),\n/* harmony export */   \"windowEndpoint\": () => (/* binding */ windowEndpoint),\n/* harmony export */   \"wrap\": () => (/* binding */ wrap)\n/* harmony export */ });\n/**\r\n * Copyright 2019 Google Inc. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst proxyMarker = Symbol(\"Comlink.proxy\");\r\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\r\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\r\nconst throwMarker = Symbol(\"Comlink.thrown\");\r\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\r\n/**\r\n * Internal transfer handle to handle objects marked to proxy.\r\n */\r\nconst proxyTransferHandler = {\r\n    canHandle: (val) => isObject(val) && val[proxyMarker],\r\n    serialize(obj) {\r\n        const { port1, port2 } = new MessageChannel();\r\n        expose(obj, port1);\r\n        return [port2, [port2]];\r\n    },\r\n    deserialize(port) {\r\n        port.start();\r\n        return wrap(port);\r\n    },\r\n};\r\n/**\r\n * Internal transfer handler to handle thrown exceptions.\r\n */\r\nconst throwTransferHandler = {\r\n    canHandle: (value) => isObject(value) && throwMarker in value,\r\n    serialize({ value }) {\r\n        let serialized;\r\n        if (value instanceof Error) {\r\n            serialized = {\r\n                isError: true,\r\n                value: {\r\n                    message: value.message,\r\n                    name: value.name,\r\n                    stack: value.stack,\r\n                },\r\n            };\r\n        }\r\n        else {\r\n            serialized = { isError: false, value };\r\n        }\r\n        return [serialized, []];\r\n    },\r\n    deserialize(serialized) {\r\n        if (serialized.isError) {\r\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\r\n        }\r\n        throw serialized.value;\r\n    },\r\n};\r\n/**\r\n * Allows customizing the serialization of certain values.\r\n */\r\nconst transferHandlers = new Map([\r\n    [\"proxy\", proxyTransferHandler],\r\n    [\"throw\", throwTransferHandler],\r\n]);\r\nfunction expose(obj, ep = self) {\r\n    ep.addEventListener(\"message\", function callback(ev) {\r\n        if (!ev || !ev.data) {\r\n            return;\r\n        }\r\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\r\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\r\n        let returnValue;\r\n        try {\r\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\r\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\r\n            switch (type) {\r\n                case 0 /* GET */:\r\n                    {\r\n                        returnValue = rawValue;\r\n                    }\r\n                    break;\r\n                case 1 /* SET */:\r\n                    {\r\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\r\n                        returnValue = true;\r\n                    }\r\n                    break;\r\n                case 2 /* APPLY */:\r\n                    {\r\n                        returnValue = rawValue.apply(parent, argumentList);\r\n                    }\r\n                    break;\r\n                case 3 /* CONSTRUCT */:\r\n                    {\r\n                        const value = new rawValue(...argumentList);\r\n                        returnValue = proxy(value);\r\n                    }\r\n                    break;\r\n                case 4 /* ENDPOINT */:\r\n                    {\r\n                        const { port1, port2 } = new MessageChannel();\r\n                        expose(obj, port2);\r\n                        returnValue = transfer(port1, [port1]);\r\n                    }\r\n                    break;\r\n                case 5 /* RELEASE */:\r\n                    {\r\n                        returnValue = undefined;\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n        catch (value) {\r\n            returnValue = { value, [throwMarker]: 0 };\r\n        }\r\n        Promise.resolve(returnValue)\r\n            .catch((value) => {\r\n            return { value, [throwMarker]: 0 };\r\n        })\r\n            .then((returnValue) => {\r\n            const [wireValue, transferables] = toWireValue(returnValue);\r\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\r\n            if (type === 5 /* RELEASE */) {\r\n                // detach and deactive after sending release response above.\r\n                ep.removeEventListener(\"message\", callback);\r\n                closeEndPoint(ep);\r\n            }\r\n        });\r\n    });\r\n    if (ep.start) {\r\n        ep.start();\r\n    }\r\n}\r\nfunction isMessagePort(endpoint) {\r\n    return endpoint.constructor.name === \"MessagePort\";\r\n}\r\nfunction closeEndPoint(endpoint) {\r\n    if (isMessagePort(endpoint))\r\n        endpoint.close();\r\n}\r\nfunction wrap(ep, target) {\r\n    return createProxy(ep, [], target);\r\n}\r\nfunction throwIfProxyReleased(isReleased) {\r\n    if (isReleased) {\r\n        throw new Error(\"Proxy has been released and is not useable\");\r\n    }\r\n}\r\nfunction createProxy(ep, path = [], target = function () { }) {\r\n    let isProxyReleased = false;\r\n    const proxy = new Proxy(target, {\r\n        get(_target, prop) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            if (prop === releaseProxy) {\r\n                return () => {\r\n                    return requestResponseMessage(ep, {\r\n                        type: 5 /* RELEASE */,\r\n                        path: path.map((p) => p.toString()),\r\n                    }).then(() => {\r\n                        closeEndPoint(ep);\r\n                        isProxyReleased = true;\r\n                    });\r\n                };\r\n            }\r\n            if (prop === \"then\") {\r\n                if (path.length === 0) {\r\n                    return { then: () => proxy };\r\n                }\r\n                const r = requestResponseMessage(ep, {\r\n                    type: 0 /* GET */,\r\n                    path: path.map((p) => p.toString()),\r\n                }).then(fromWireValue);\r\n                return r.then.bind(r);\r\n            }\r\n            return createProxy(ep, [...path, prop]);\r\n        },\r\n        set(_target, prop, rawValue) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\r\n            // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\r\n            const [value, transferables] = toWireValue(rawValue);\r\n            return requestResponseMessage(ep, {\r\n                type: 1 /* SET */,\r\n                path: [...path, prop].map((p) => p.toString()),\r\n                value,\r\n            }, transferables).then(fromWireValue);\r\n        },\r\n        apply(_target, _thisArg, rawArgumentList) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            const last = path[path.length - 1];\r\n            if (last === createEndpoint) {\r\n                return requestResponseMessage(ep, {\r\n                    type: 4 /* ENDPOINT */,\r\n                }).then(fromWireValue);\r\n            }\r\n            // We just pretend that `bind()` didn’t happen.\r\n            if (last === \"bind\") {\r\n                return createProxy(ep, path.slice(0, -1));\r\n            }\r\n            const [argumentList, transferables] = processArguments(rawArgumentList);\r\n            return requestResponseMessage(ep, {\r\n                type: 2 /* APPLY */,\r\n                path: path.map((p) => p.toString()),\r\n                argumentList,\r\n            }, transferables).then(fromWireValue);\r\n        },\r\n        construct(_target, rawArgumentList) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            const [argumentList, transferables] = processArguments(rawArgumentList);\r\n            return requestResponseMessage(ep, {\r\n                type: 3 /* CONSTRUCT */,\r\n                path: path.map((p) => p.toString()),\r\n                argumentList,\r\n            }, transferables).then(fromWireValue);\r\n        },\r\n    });\r\n    return proxy;\r\n}\r\nfunction myFlat(arr) {\r\n    return Array.prototype.concat.apply([], arr);\r\n}\r\nfunction processArguments(argumentList) {\r\n    const processed = argumentList.map(toWireValue);\r\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\r\n}\r\nconst transferCache = new WeakMap();\r\nfunction transfer(obj, transfers) {\r\n    transferCache.set(obj, transfers);\r\n    return obj;\r\n}\r\nfunction proxy(obj) {\r\n    return Object.assign(obj, { [proxyMarker]: true });\r\n}\r\nfunction windowEndpoint(w, context = self, targetOrigin = \"*\") {\r\n    return {\r\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\r\n        addEventListener: context.addEventListener.bind(context),\r\n        removeEventListener: context.removeEventListener.bind(context),\r\n    };\r\n}\r\nfunction toWireValue(value) {\r\n    for (const [name, handler] of transferHandlers) {\r\n        if (handler.canHandle(value)) {\r\n            const [serializedValue, transferables] = handler.serialize(value);\r\n            return [\r\n                {\r\n                    type: 3 /* HANDLER */,\r\n                    name,\r\n                    value: serializedValue,\r\n                },\r\n                transferables,\r\n            ];\r\n        }\r\n    }\r\n    return [\r\n        {\r\n            type: 0 /* RAW */,\r\n            value,\r\n        },\r\n        transferCache.get(value) || [],\r\n    ];\r\n}\r\nfunction fromWireValue(value) {\r\n    switch (value.type) {\r\n        case 3 /* HANDLER */:\r\n            return transferHandlers.get(value.name).deserialize(value.value);\r\n        case 0 /* RAW */:\r\n            return value.value;\r\n    }\r\n}\r\nfunction requestResponseMessage(ep, msg, transfers) {\r\n    return new Promise((resolve) => {\r\n        const id = generateUUID();\r\n        ep.addEventListener(\"message\", function l(ev) {\r\n            if (!ev.data || !ev.data.id || ev.data.id !== id) {\r\n                return;\r\n            }\r\n            ep.removeEventListener(\"message\", l);\r\n            resolve(ev.data);\r\n        });\r\n        if (ep.start) {\r\n            ep.start();\r\n        }\r\n        ep.postMessage(Object.assign({ id }, msg), transfers);\r\n    });\r\n}\r\nfunction generateUUID() {\r\n    return new Array(4)\r\n        .fill(0)\r\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\r\n        .join(\"-\");\r\n}\n\n\n//# sourceMappingURL=comlink.mjs.map\n\n\n//# sourceURL=webpack://rollup/./node_modules/comlink/dist/esm/comlink.mjs?");

/***/ }),

/***/ "./node_modules/ts-loader/index.js!./src/offScreen-worker.ts":
/*!*******************************************************************!*\
  !*** ./node_modules/ts-loader/index.js!./src/offScreen-worker.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var comlink__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! comlink */ \"./node_modules/comlink/dist/esm/comlink.mjs\");\n/* harmony import */ var webgl_plot__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! webgl-plot */ \"./node_modules/webgl-plot/dist/webglplot.js\");\n\r\n\r\nconst exports = {\r\n    amp: 0.5,\r\n    run(canvas) {\r\n        console.log(\"😉\");\r\n        //const canvas = this.getElementById(\"my_canvas\") as HTMLCanvasElement;\r\n        console.log(canvas);\r\n        const numX = canvas.width;\r\n        const color = new webgl_plot__WEBPACK_IMPORTED_MODULE_1__.ColorRGBA(Math.random(), Math.random(), Math.random(), 1);\r\n        const line = new webgl_plot__WEBPACK_IMPORTED_MODULE_1__.WebglLine(color, numX);\r\n        const wglp = new webgl_plot__WEBPACK_IMPORTED_MODULE_1__.WebglPlot(canvas);\r\n        line.lineSpaceX(-1, 2 / numX);\r\n        wglp.addDataLine(line);\r\n        function newFrame() {\r\n            update();\r\n            wglp.update();\r\n            requestAnimationFrame(newFrame);\r\n        }\r\n        requestAnimationFrame(newFrame);\r\n        function update() {\r\n            const freq = 0.001;\r\n            //const amp = 0.5;\r\n            const noise = 0.1;\r\n            for (let i = 0; i < line.numPoints; i++) {\r\n                const ySin = Math.sin(Math.PI * i * freq * Math.PI * 2);\r\n                const yNoise = Math.random() - 0.5;\r\n                line.setY(i, ySin * exports.amp + yNoise * noise);\r\n            }\r\n        }\r\n        return;\r\n    },\r\n    set(a) {\r\n        exports.amp = a;\r\n        return;\r\n    },\r\n};\r\n(0,comlink__WEBPACK_IMPORTED_MODULE_0__.expose)(exports);\r\n\n\n//# sourceURL=webpack://rollup/./src/offScreen-worker.ts?./node_modules/ts-loader/index.js");

/***/ }),

/***/ "./node_modules/webgl-plot/dist/webglplot.js":
/*!***************************************************!*\
  !*** ./node_modules/webgl-plot/dist/webglplot.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ColorRGBA\": () => (/* binding */ ColorRGBA),\n/* harmony export */   \"WebglLine\": () => (/* binding */ WebglLine),\n/* harmony export */   \"WebglPlot\": () => (/* binding */ WebglPlot),\n/* harmony export */   \"WebglPolar\": () => (/* binding */ WebglPolar),\n/* harmony export */   \"WebglSquare\": () => (/* binding */ WebglSquare),\n/* harmony export */   \"WebglStep\": () => (/* binding */ WebglStep)\n/* harmony export */ });\nclass ColorRGBA {\r\n    constructor(r, g, b, a) {\r\n        this.r = r;\r\n        this.g = g;\r\n        this.b = b;\r\n        this.a = a;\r\n    }\r\n}\n\n/**\r\n * Baseline class\r\n */\r\nclass WebglBaseLine {\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor() {\r\n        this.scaleX = 1;\r\n        this.scaleY = 1;\r\n        this.offsetX = 0;\r\n        this.offsetY = 0;\r\n        this.loop = false;\r\n        this._vbuffer = 0;\r\n        this._coord = 0;\r\n        this.visible = true;\r\n        this.intensity = 1;\r\n        this.xy = new Float32Array([]);\r\n        this.numPoints = 0;\r\n        this.color = new ColorRGBA(0, 0, 0, 1);\r\n        this.webglNumPoints = 0;\r\n    }\r\n}\n\n/**\r\n * The standard Line class\r\n */\r\nclass WebglLine extends WebglBaseLine {\r\n    /**\r\n     * Create a new line\r\n     * @param c - the color of the line\r\n     * @param numPoints - number of data pints\r\n     * @example\r\n     * ```typescript\r\n     * x= [0,1]\r\n     * y= [1,2]\r\n     * line = new WebglLine( new ColorRGBA(0.1,0.1,0.1,1), 2);\r\n     * ```\r\n     */\r\n    constructor(c, numPoints) {\r\n        super();\r\n        this.webglNumPoints = numPoints;\r\n        this.numPoints = numPoints;\r\n        this.color = c;\r\n        this.xy = new Float32Array(2 * this.webglNumPoints);\r\n    }\r\n    /**\r\n     * Set the X value at a specific index\r\n     * @param index - the index of the data point\r\n     * @param x - the horizontal value of the data point\r\n     */\r\n    setX(index, x) {\r\n        this.xy[index * 2] = x;\r\n    }\r\n    /**\r\n     * Set the Y value at a specific index\r\n     * @param index : the index of the data point\r\n     * @param y : the vertical value of the data point\r\n     */\r\n    setY(index, y) {\r\n        this.xy[index * 2 + 1] = y;\r\n    }\r\n    /**\r\n     * Get an X value at a specific index\r\n     * @param index - the index of X\r\n     */\r\n    getX(index) {\r\n        return this.xy[index * 2];\r\n    }\r\n    /**\r\n     * Get an Y value at a specific index\r\n     * @param index - the index of Y\r\n     */\r\n    getY(index) {\r\n        return this.xy[index * 2 + 1];\r\n    }\r\n    /**\r\n     * Make an equally spaced array of X points\r\n     * @param start  - the start of the series\r\n     * @param stepSize - step size between each data point\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * //x = [-1, -0.8, -0.6, -0.4, -0.2, 0, 0.2, 0.4, 0.6, 0.8]\r\n     * const numX = 10;\r\n     * line.lineSpaceX(-1, 2 / numX);\r\n     * ```\r\n     */\r\n    lineSpaceX(start, stepSize) {\r\n        for (let i = 0; i < this.numPoints; i++) {\r\n            // set x to -num/2:1:+num/2\r\n            this.setX(i, start + stepSize * i);\r\n        }\r\n    }\r\n    /**\r\n     * Set a constant value for all Y values in the line\r\n     * @param c - constant value\r\n     */\r\n    constY(c) {\r\n        for (let i = 0; i < this.numPoints; i++) {\r\n            // set x to -num/2:1:+num/2\r\n            this.setY(i, c);\r\n        }\r\n    }\r\n    /**\r\n     * Add a new Y values to the end of current array and shift it, so that the total number of the pair remains the same\r\n     * @param data - the Y array\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * yArray = new Float32Array([3, 4, 5]);\r\n     * line.shiftAdd(yArray);\r\n     * ```\r\n     */\r\n    shiftAdd(data) {\r\n        const shiftSize = data.length;\r\n        for (let i = 0; i < this.numPoints - shiftSize; i++) {\r\n            this.setY(i, this.getY(i + shiftSize));\r\n        }\r\n        for (let i = 0; i < shiftSize; i++) {\r\n            this.setY(i + this.numPoints - shiftSize, data[i]);\r\n        }\r\n    }\r\n}\n\n/**\r\n * The step based line plot\r\n */\r\nclass WebglStep extends WebglBaseLine {\r\n    /**\r\n     * Create a new step line\r\n     * @param c - the color of the line\r\n     * @param numPoints - number of data pints\r\n     * @example\r\n     * ```typescript\r\n     * x= [0,1]\r\n     * y= [1,2]\r\n     * line = new WebglStep( new ColorRGBA(0.1,0.1,0.1,1), 2);\r\n     * ```\r\n     */\r\n    constructor(c, num) {\r\n        super();\r\n        this.webglNumPoints = num * 2;\r\n        this.numPoints = num;\r\n        this.color = c;\r\n        this.xy = new Float32Array(2 * this.webglNumPoints);\r\n    }\r\n    /**\r\n     * Set the Y value at a specific index\r\n     * @param index - the index of the data point\r\n     * @param y - the vertical value of the data point\r\n     */\r\n    setY(index, y) {\r\n        this.xy[index * 4 + 1] = y;\r\n        this.xy[index * 4 + 3] = y;\r\n    }\r\n    getX(index) {\r\n        return this.xy[index * 4];\r\n    }\r\n    /**\r\n     * Get an X value at a specific index\r\n     * @param index - the index of X\r\n     */\r\n    getY(index) {\r\n        return this.xy[index * 4 + 1];\r\n    }\r\n    /**\r\n     * Make an equally spaced array of X points\r\n     * @param start  - the start of the series\r\n     * @param stepSize - step size between each data point\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * //x = [-1, -0.8, -0.6, -0.4, -0.2, 0, 0.2, 0.4, 0.6, 0.8]\r\n     * const numX = 10;\r\n     * line.lineSpaceX(-1, 2 / numX);\r\n     * ```\r\n     */\r\n    lineSpaceX(start, stepsize) {\r\n        for (let i = 0; i < this.numPoints; i++) {\r\n            // set x to -num/2:1:+num/2\r\n            this.xy[i * 4] = start + i * stepsize;\r\n            this.xy[i * 4 + 2] = start + (i * stepsize + stepsize);\r\n        }\r\n    }\r\n    /**\r\n     * Set a constant value for all Y values in the line\r\n     * @param c - constant value\r\n     */\r\n    constY(c) {\r\n        for (let i = 0; i < this.numPoints; i++) {\r\n            // set x to -num/2:1:+num/2\r\n            this.setY(i, c);\r\n        }\r\n    }\r\n    /**\r\n     * Add a new Y values to the end of current array and shift it, so that the total number of the pair remains the same\r\n     * @param data - the Y array\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * yArray = new Float32Array([3, 4, 5]);\r\n     * line.shiftAdd(yArray);\r\n     * ```\r\n     */\r\n    shiftAdd(data) {\r\n        const shiftSize = data.length;\r\n        for (let i = 0; i < this.numPoints - shiftSize; i++) {\r\n            this.setY(i, this.getY(i + shiftSize));\r\n        }\r\n        for (let i = 0; i < shiftSize; i++) {\r\n            this.setY(i + this.numPoints - shiftSize, data[i]);\r\n        }\r\n    }\r\n}\n\nclass WebglPolar extends WebglBaseLine {\r\n    constructor(c, numPoints) {\r\n        super();\r\n        this.webglNumPoints = numPoints;\r\n        this.numPoints = numPoints;\r\n        this.color = c;\r\n        this.intenisty = 1;\r\n        this.xy = new Float32Array(2 * this.webglNumPoints);\r\n        this._vbuffer = 0;\r\n        this._coord = 0;\r\n        this.visible = true;\r\n        this.offsetTheta = 0;\r\n    }\r\n    /**\r\n     * @param index: index of the line\r\n     * @param theta : angle in deg\r\n     * @param r : radius\r\n     */\r\n    setRtheta(index, theta, r) {\r\n        //const rA = Math.abs(r);\r\n        //const thetaA = theta % 360;\r\n        const x = r * Math.cos((2 * Math.PI * (theta + this.offsetTheta)) / 360);\r\n        const y = r * Math.sin((2 * Math.PI * (theta + this.offsetTheta)) / 360);\r\n        //const index = Math.round( ((theta % 360)/360) * this.numPoints );\r\n        this.setX(index, x);\r\n        this.setY(index, y);\r\n    }\r\n    getTheta(index) {\r\n        //return Math.tan\r\n        return 0;\r\n    }\r\n    getR(index) {\r\n        //return Math.tan\r\n        return Math.sqrt(Math.pow(this.getX(index), 2) + Math.pow(this.getY(index), 2));\r\n    }\r\n    setX(index, x) {\r\n        this.xy[index * 2] = x;\r\n    }\r\n    setY(index, y) {\r\n        this.xy[index * 2 + 1] = y;\r\n    }\r\n    getX(index) {\r\n        return this.xy[index * 2];\r\n    }\r\n    getY(index) {\r\n        return this.xy[index * 2 + 1];\r\n    }\r\n}\n\n/**\r\n * The Square class\r\n */\r\nclass WebglSquare extends WebglBaseLine {\r\n    /**\r\n     * Create a new line\r\n     * @param c - the color of the line\r\n     * @example\r\n     * ```typescript\r\n     * line = new WebglSquare( new ColorRGBA(0.1,0.1,0.1,0.5) );\r\n     * ```\r\n     */\r\n    constructor(c) {\r\n        super();\r\n        this.webglNumPoints = 4;\r\n        this.numPoints = 4;\r\n        this.color = c;\r\n        this.xy = new Float32Array(2 * this.webglNumPoints);\r\n    }\r\n    /**\r\n     * draw a square\r\n     * @param x1 start x\r\n     * @param y1 start y\r\n     * @param x2 end x\r\n     * @param y2 end y\r\n     */\r\n    setSquare(x1, y1, x2, y2) {\r\n        this.xy = new Float32Array([x1, y1, x1, y2, x2, y1, x2, y2]);\r\n    }\r\n}\n\n/**\r\n * Author Danial Chitnis 2019-20\r\n *\r\n * inspired by:\r\n * https://codepen.io/AzazelN28\r\n * https://www.tutorialspoint.com/webgl/webgl_modes_of_drawing.htm\r\n */\r\n/**\r\n * The main class for the webgl-plot library\r\n */\r\nclass WebglPlot {\r\n    /**\r\n     * Create a webgl-plot instance\r\n     * @param canvas - the canvas in which the plot appears\r\n     * @param debug - (Optional) log debug messages to console\r\n     *\r\n     * @example\r\n     *\r\n     * For HTMLCanvas\r\n     * ```typescript\r\n     * const canvas = document.getElementbyId(\"canvas\");\r\n     *\r\n     * const devicePixelRatio = window.devicePixelRatio || 1;\r\n     * canvas.width = canvas.clientWidth * devicePixelRatio;\r\n     * canvas.height = canvas.clientHeight * devicePixelRatio;\r\n     *\r\n     * const webglp = new WebGLplot(canvas);\r\n     * ...\r\n     * ```\r\n     * @example\r\n     *\r\n     * For OffScreenCanvas\r\n     * ```typescript\r\n     * const offscreen = htmlCanvas.transferControlToOffscreen();\r\n     *\r\n     * offscreen.width = htmlCanvas.clientWidth * window.devicePixelRatio;\r\n     * offscreen.height = htmlCanvas.clientHeight * window.devicePixelRatio;\r\n     *\r\n     * const worker = new Worker(\"offScreenCanvas.js\", { type: \"module\" });\r\n     * worker.postMessage({ canvas: offscreen }, [offscreen]);\r\n     * ```\r\n     * Then in offScreenCanvas.js\r\n     * ```typescript\r\n     * onmessage = function (evt) {\r\n     * const wglp = new WebGLplot(evt.data.canvas);\r\n     * ...\r\n     * }\r\n     * ```\r\n     */\r\n    constructor(canvas, options) {\r\n        /**\r\n         * log debug output\r\n         */\r\n        this.debug = false;\r\n        this.addLine = this.addDataLine;\r\n        if (options == undefined) {\r\n            this.webgl = canvas.getContext(\"webgl\", {\r\n                antialias: true,\r\n                transparent: false,\r\n            });\r\n        }\r\n        else {\r\n            this.webgl = canvas.getContext(\"webgl\", {\r\n                antialias: options.antialias,\r\n                transparent: options.transparent,\r\n                desynchronized: options.deSync,\r\n                powerPerformance: options.powerPerformance,\r\n                preserveDrawing: options.preserveDrawing,\r\n            });\r\n            this.debug = options.debug == undefined ? false : options.debug;\r\n        }\r\n        this.log(\"canvas type is: \" + canvas.constructor.name);\r\n        this.log(`[webgl-plot]:width=${canvas.width}, height=${canvas.height}`);\r\n        this._linesData = [];\r\n        this._linesAux = [];\r\n        this._surfaces = [];\r\n        //this.webgl = webgl;\r\n        this.gScaleX = 1;\r\n        this.gScaleY = 1;\r\n        this.gXYratio = 1;\r\n        this.gOffsetX = 0;\r\n        this.gOffsetY = 0;\r\n        this.gLog10X = false;\r\n        this.gLog10Y = false;\r\n        // Clear the color\r\n        this.webgl.clear(this.webgl.COLOR_BUFFER_BIT);\r\n        // Set the view port\r\n        this.webgl.viewport(0, 0, canvas.width, canvas.height);\r\n        this.progThinLine = this.webgl.createProgram();\r\n        this.initThinLineProgram();\r\n        //https://learnopengl.com/Advanced-OpenGL/Blending\r\n        this.webgl.enable(this.webgl.BLEND);\r\n        this.webgl.blendFunc(this.webgl.SRC_ALPHA, this.webgl.ONE_MINUS_SRC_ALPHA);\r\n    }\r\n    get linesData() {\r\n        return this._linesData;\r\n    }\r\n    get linesAux() {\r\n        return this._linesAux;\r\n    }\r\n    get surfaces() {\r\n        return this._surfaces;\r\n    }\r\n    /**\r\n     * updates and redraws the content of the plot\r\n     */\r\n    updateLines(lines) {\r\n        const webgl = this.webgl;\r\n        lines.forEach((line) => {\r\n            if (line.visible) {\r\n                webgl.useProgram(this.progThinLine);\r\n                const uscale = webgl.getUniformLocation(this.progThinLine, \"uscale\");\r\n                webgl.uniformMatrix2fv(uscale, false, new Float32Array([\r\n                    line.scaleX * this.gScaleX * (this.gLog10X ? 1 / Math.log(10) : 1),\r\n                    0,\r\n                    0,\r\n                    line.scaleY * this.gScaleY * this.gXYratio * (this.gLog10Y ? 1 / Math.log(10) : 1),\r\n                ]));\r\n                const uoffset = webgl.getUniformLocation(this.progThinLine, \"uoffset\");\r\n                webgl.uniform2fv(uoffset, new Float32Array([line.offsetX + this.gOffsetX, line.offsetY + this.gOffsetY]));\r\n                const isLog = webgl.getUniformLocation(this.progThinLine, \"is_log\");\r\n                webgl.uniform2iv(isLog, new Int32Array([this.gLog10X ? 1 : 0, this.gLog10Y ? 1 : 0]));\r\n                const uColor = webgl.getUniformLocation(this.progThinLine, \"uColor\");\r\n                webgl.uniform4fv(uColor, [line.color.r, line.color.g, line.color.b, line.color.a]);\r\n                webgl.bufferData(webgl.ARRAY_BUFFER, line.xy, webgl.STREAM_DRAW);\r\n                webgl.drawArrays(line.loop ? webgl.LINE_LOOP : webgl.LINE_STRIP, 0, line.webglNumPoints);\r\n            }\r\n        });\r\n    }\r\n    updateSurfaces(lines) {\r\n        const webgl = this.webgl;\r\n        lines.forEach((line) => {\r\n            if (line.visible) {\r\n                webgl.useProgram(this.progThinLine);\r\n                const uscale = webgl.getUniformLocation(this.progThinLine, \"uscale\");\r\n                webgl.uniformMatrix2fv(uscale, false, new Float32Array([\r\n                    line.scaleX * this.gScaleX * (this.gLog10X ? 1 / Math.log(10) : 1),\r\n                    0,\r\n                    0,\r\n                    line.scaleY * this.gScaleY * this.gXYratio * (this.gLog10Y ? 1 / Math.log(10) : 1),\r\n                ]));\r\n                const uoffset = webgl.getUniformLocation(this.progThinLine, \"uoffset\");\r\n                webgl.uniform2fv(uoffset, new Float32Array([line.offsetX + this.gOffsetX, line.offsetY + this.gOffsetY]));\r\n                const isLog = webgl.getUniformLocation(this.progThinLine, \"is_log\");\r\n                webgl.uniform2iv(isLog, new Int32Array([this.gLog10X ? 1 : 0, this.gLog10Y ? 1 : 0]));\r\n                const uColor = webgl.getUniformLocation(this.progThinLine, \"uColor\");\r\n                webgl.uniform4fv(uColor, [line.color.r, line.color.g, line.color.b, line.color.a]);\r\n                webgl.bufferData(webgl.ARRAY_BUFFER, line.xy, webgl.STREAM_DRAW);\r\n                webgl.drawArrays(webgl.TRIANGLE_STRIP, 0, line.webglNumPoints);\r\n            }\r\n        });\r\n    }\r\n    update() {\r\n        this.updateLines(this.linesData);\r\n        this.updateLines(this.linesAux);\r\n        this.updateSurfaces(this.surfaces);\r\n    }\r\n    clear() {\r\n        // Clear the canvas  //??????????????????\r\n        //this.webgl.clearColor(0.1, 0.1, 0.1, 1.0);\r\n        this.webgl.clear(this.webgl.COLOR_BUFFER_BIT);\r\n    }\r\n    /**\r\n     * adds a line to the plot\r\n     * @param line - this could be any of line, linestep, histogram, or polar\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const line = new line(color, numPoints);\r\n     * wglp.addLine(line);\r\n     * ```\r\n     */\r\n    _addLine(line) {\r\n        //line.initProgram(this.webgl);\r\n        line._vbuffer = this.webgl.createBuffer();\r\n        this.webgl.bindBuffer(this.webgl.ARRAY_BUFFER, line._vbuffer);\r\n        this.webgl.bufferData(this.webgl.ARRAY_BUFFER, line.xy, this.webgl.STREAM_DRAW);\r\n        this.webgl.bindBuffer(this.webgl.ARRAY_BUFFER, line._vbuffer);\r\n        line._coord = this.webgl.getAttribLocation(this.progThinLine, \"coordinates\");\r\n        this.webgl.vertexAttribPointer(line._coord, 2, this.webgl.FLOAT, false, 0, 0);\r\n        this.webgl.enableVertexAttribArray(line._coord);\r\n    }\r\n    addDataLine(line) {\r\n        this._addLine(line);\r\n        this.linesData.push(line);\r\n    }\r\n    addAuxLine(line) {\r\n        this._addLine(line);\r\n        this.linesAux.push(line);\r\n    }\r\n    addSurface(surface) {\r\n        this._addLine(surface);\r\n        this.surfaces.push(surface);\r\n    }\r\n    initThinLineProgram() {\r\n        const vertCode = `\r\n      attribute vec2 coordinates;\r\n      uniform mat2 uscale;\r\n      uniform vec2 uoffset;\r\n      uniform ivec2 is_log;\r\n\r\n      void main(void) {\r\n         float x = (is_log[0]==1) ? log(coordinates.x) : coordinates.x;\r\n         float y = (is_log[1]==1) ? log(coordinates.y) : coordinates.y;\r\n         vec2 line = vec2(x, y);\r\n         gl_Position = vec4(uscale*line + uoffset, 0.0, 1.0);\r\n      }`;\r\n        // Create a vertex shader object\r\n        const vertShader = this.webgl.createShader(this.webgl.VERTEX_SHADER);\r\n        // Attach vertex shader source code\r\n        this.webgl.shaderSource(vertShader, vertCode);\r\n        // Compile the vertex shader\r\n        this.webgl.compileShader(vertShader);\r\n        // Fragment shader source code\r\n        const fragCode = `\r\n         precision mediump float;\r\n         uniform highp vec4 uColor;\r\n         void main(void) {\r\n            gl_FragColor =  uColor;\r\n         }`;\r\n        const fragShader = this.webgl.createShader(this.webgl.FRAGMENT_SHADER);\r\n        this.webgl.shaderSource(fragShader, fragCode);\r\n        this.webgl.compileShader(fragShader);\r\n        this.progThinLine = this.webgl.createProgram();\r\n        this.webgl.attachShader(this.progThinLine, vertShader);\r\n        this.webgl.attachShader(this.progThinLine, fragShader);\r\n        this.webgl.linkProgram(this.progThinLine);\r\n    }\r\n    /**\r\n     * remove the last data line\r\n     */\r\n    popDataLine() {\r\n        this.linesData.pop();\r\n    }\r\n    /**\r\n     * remove all the lines\r\n     */\r\n    removeAllLines() {\r\n        this._linesData = [];\r\n        this._linesAux = [];\r\n    }\r\n    /**\r\n     * remove all data lines\r\n     */\r\n    removeDataLines() {\r\n        this._linesData = [];\r\n    }\r\n    /**\r\n     * remove all auxiliary lines\r\n     */\r\n    removeAuxLines() {\r\n        this._linesAux = [];\r\n    }\r\n    /**\r\n     * Change the WbGL viewport\r\n     * @param a\r\n     * @param b\r\n     * @param c\r\n     * @param d\r\n     */\r\n    viewport(a, b, c, d) {\r\n        this.webgl.viewport(a, b, c, d);\r\n    }\r\n    log(str) {\r\n        if (this.debug) {\r\n            console.log(\"[webgl-plot]:\" + str);\r\n        }\r\n    }\r\n}\n\n\n\n\n//# sourceURL=webpack://rollup/./node_modules/webgl-plot/dist/webglplot.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./node_modules/ts-loader/index.js!./src/offScreen-worker.ts");
/******/ 	
/******/ })()
;