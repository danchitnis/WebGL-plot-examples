/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is not neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./dist/static.js":
/*!************************!*\
  !*** ./dist/static.js ***!
  \************************/
/*! namespace exports */
/*! exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_require__.r, __webpack_exports__, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var webgl_plot__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! webgl-plot */ \"./node_modules/webgl-plot/dist/webglplot.esm.js\");\n\r\nconst numLines = 1;\r\nconst amp = 0.5;\r\nconst noise = 0.1;\r\nconst freq = 0.01;\r\nconst canvas = document.getElementById(\"my_canvas\");\r\nlet numX;\r\nlet display;\r\nlet wglp;\r\nlet lines;\r\nlet Rect;\r\nlet scale = 1;\r\nlet offset = 0;\r\nlet pinchZoom = false;\r\nlet drag = false;\r\nlet zoom = false;\r\nlet dragInitialX = 0;\r\nlet dragOffsetOld = 0;\r\nlet initialX = 0;\r\nconst devicePixelRatio = window.devicePixelRatio || 1;\r\ncreateUI();\r\ninit();\r\nlet resizeId;\r\nwindow.addEventListener(\"resize\", () => {\r\n    window.clearTimeout(resizeId);\r\n    resizeId = window.setTimeout(doneResizing, 500);\r\n});\r\nfunction newFrame() {\r\n    update();\r\n    //wglp.clear();\r\n    wglp.update();\r\n    window.requestAnimationFrame(newFrame);\r\n}\r\nwindow.requestAnimationFrame(newFrame);\r\nfunction init() {\r\n    //const devicePixelRatio = 1;\r\n    canvas.width = canvas.clientWidth * devicePixelRatio;\r\n    canvas.height = canvas.clientHeight * devicePixelRatio;\r\n    //numX = Math.round(canv.clientWidth * devicePixelRatio);\r\n    numX = 100000;\r\n    lines = [];\r\n    for (let i = 0; i < numLines; i++) {\r\n        const color = new webgl_plot__WEBPACK_IMPORTED_MODULE_0__.ColorRGBA(Math.random(), Math.random(), Math.random(), 1);\r\n        lines.push(new webgl_plot__WEBPACK_IMPORTED_MODULE_0__.WebglLine(color, numX));\r\n    }\r\n    wglp = new webgl_plot__WEBPACK_IMPORTED_MODULE_0__.default(canvas);\r\n    wglp.viewport(0, 0, canvas.width, canvas.height);\r\n    // wglp.offsetX = -1;\r\n    // wglp.scaleX = 2;\r\n    lines.forEach((line) => {\r\n        line.lineSpaceX(-1, 2 / numX);\r\n        wglp.addLine(line);\r\n    });\r\n    // add zoom rectangle\r\n    Rect = new webgl_plot__WEBPACK_IMPORTED_MODULE_0__.WebglLine(new webgl_plot__WEBPACK_IMPORTED_MODULE_0__.ColorRGBA(0.9, 0.9, 0.9, 1), 4);\r\n    Rect.loop = true;\r\n    Rect.xy = new Float32Array([-0.5, -1, -0.5, 1, 0.5, 1, 0.5, -1]);\r\n    Rect.visible = false;\r\n    wglp.addLine(Rect);\r\n    // test rec\r\n    const testRect = new webgl_plot__WEBPACK_IMPORTED_MODULE_0__.WebglLine(new webgl_plot__WEBPACK_IMPORTED_MODULE_0__.ColorRGBA(0.1, 0.9, 0.9, 1), 4);\r\n    testRect.loop = true;\r\n    testRect.xy = new Float32Array([-0.7, -0.8, -0.7, 0.8, -0.6, 0.8, -0.6, -0.8]);\r\n    wglp.addLine(testRect);\r\n    /*for (let j = 0; j < lines.length; j++) {\r\n      for (let i = 0; i < lines[j].numPoints; i++) {\r\n        const ySin = Math.sin(Math.PI * i * freq + (j / lines.length) * Math.PI * 2);\r\n        const yNoise = Math.random() - 0.5;\r\n        lines[j].setY(i, ySin * amp + yNoise * noise);\r\n      }\r\n    }*/\r\n    for (let j = 0; j < lines.length; j++) {\r\n        for (let i = 1; i < lines[j].numPoints; i++) {\r\n            let y = lines[j].getY(i - 1) + 0.01 * (Math.round(Math.random()) - 0.5);\r\n            if (y > 0.9) {\r\n                y = 0.9;\r\n            }\r\n            if (y < -0.9) {\r\n                y = -0.9;\r\n            }\r\n            lines[j].setY(i, y);\r\n        }\r\n    }\r\n    //wglp.viewport(0, 0, 1000, 1000);\r\n    wglp.gScaleX = 1;\r\n    canvas.addEventListener(\"wheel\", zoomEvent);\r\n    canvas.addEventListener(\"touchstart\", touchStart);\r\n    canvas.addEventListener(\"touchmove\", touchMove);\r\n    canvas.addEventListener(\"touchend\", touchEnd);\r\n    canvas.addEventListener(\"mousedown\", mouseDown);\r\n    canvas.addEventListener(\"mousemove\", mouseMove);\r\n    canvas.addEventListener(\"mouseup\", mouseUp);\r\n    canvas.addEventListener(\"dblclick\", dblClick);\r\n    canvas.addEventListener(\"contextmenu\", contextMenu);\r\n    canvas.style.cursor = \"zoom-in\";\r\n    //window.addEventListener(\"keydown\", keyEvent);\r\n}\r\nfunction update() {\r\n    if (wglp) {\r\n        display.innerHTML =\r\n            \"Zoom: \" + wglp.gScaleX.toFixed(2) + \", Offset: \" + wglp.gOffsetX.toFixed(2);\r\n    }\r\n}\r\nfunction dblClick(e) {\r\n    e.preventDefault();\r\n    wglp.gScaleX = 1;\r\n    wglp.gOffsetX = 0;\r\n}\r\nfunction contextMenu(e) {\r\n    e.preventDefault();\r\n}\r\nlet cursorDownX = 0;\r\nfunction mouseDown(e) {\r\n    e.preventDefault();\r\n    console.log(e.clientX);\r\n    if (e.button == 0) {\r\n        zoom = true;\r\n        canvas.style.cursor = \"pointer\";\r\n        cursorDownX = (2 * (e.clientX * devicePixelRatio - canvas.width / 2)) / canvas.width;\r\n        //cursorDownX = (cursorDownX - wglp.gOffsetX) / wglp.gScaleX;\r\n        Rect.visible = true;\r\n    }\r\n    if (e.button == 2) {\r\n        drag = true;\r\n        canvas.style.cursor = \"grabbing\";\r\n        dragInitialX = e.clientX * devicePixelRatio;\r\n        dragOffsetOld = wglp.gOffsetX;\r\n    }\r\n}\r\nfunction mouseMove(e) {\r\n    e.preventDefault();\r\n    if (zoom) {\r\n        const cursorOffsetX = (2 * (e.clientX * devicePixelRatio - canvas.width / 2)) / canvas.width;\r\n        Rect.xy = new Float32Array([\r\n            (cursorDownX - wglp.gOffsetX) / wglp.gScaleX,\r\n            -1,\r\n            (cursorDownX - wglp.gOffsetX) / wglp.gScaleX,\r\n            1,\r\n            (cursorOffsetX - wglp.gOffsetX) / wglp.gScaleX,\r\n            1,\r\n            (cursorOffsetX - wglp.gOffsetX) / wglp.gScaleX,\r\n            -1,\r\n        ]);\r\n        Rect.visible = true;\r\n    }\r\n    if (drag) {\r\n        const moveX = e.clientX * devicePixelRatio - dragInitialX;\r\n        const offsetX = (wglp.gScaleY * moveX) / 1000;\r\n        wglp.gOffsetX = offsetX + dragOffsetOld;\r\n    }\r\n}\r\nfunction mouseUp(e) {\r\n    e.preventDefault();\r\n    if (zoom) {\r\n        const cursorUpX = (2 * (e.clientX * devicePixelRatio - canvas.width / 2)) / canvas.width;\r\n        const zoomFactor = Math.abs(cursorUpX - cursorDownX) / (2 * wglp.gScaleX);\r\n        const offsetFactor = (cursorDownX + cursorUpX - 2 * wglp.gOffsetX) / (2 * wglp.gScaleX);\r\n        if (zoomFactor > 0) {\r\n            wglp.gScaleX = 1 / zoomFactor;\r\n            wglp.gOffsetX = -offsetFactor / zoomFactor;\r\n        }\r\n    }\r\n    zoom = false;\r\n    drag = false;\r\n    canvas.style.cursor = \"zoom-in\";\r\n    //Rect.visible = false;\r\n}\r\nfunction zoomEvent(e) {\r\n    e.preventDefault();\r\n    const cursorOffsetX = (-2 * (e.clientX * devicePixelRatio - canvas.width / 2)) / canvas.width;\r\n    if (e.shiftKey) {\r\n        offset += e.deltaY * 0.1;\r\n        wglp.gOffsetX = 0.1 * offset;\r\n    }\r\n    else {\r\n        scale += e.deltaY * -0.01;\r\n        scale = Math.min(100, scale);\r\n        scale = Math.max(1, scale);\r\n        const gScaleXOld = wglp.gScaleX;\r\n        wglp.gScaleX = 1 * Math.pow(scale, 1.5);\r\n        if (scale > 1 && scale < 100) {\r\n            wglp.gOffsetX = ((wglp.gOffsetX + cursorOffsetX) * wglp.gScaleX) / gScaleXOld;\r\n        }\r\n        if (scale <= 1) {\r\n            wglp.gOffsetX = 0;\r\n        }\r\n    }\r\n}\r\n/*\r\n * Pinch and Zoom\r\n **/\r\nfunction touchStart(e) {\r\n    //\r\n    e.preventDefault();\r\n    log(\"touched\");\r\n    if (e.touches.length == 2) {\r\n        pinchZoom = true;\r\n        drag = false;\r\n        initialX = e.touches[0].pageX - e.touches[1].pageX;\r\n        log(\"pinch started\");\r\n    }\r\n    if (e.touches.length == 1) {\r\n        drag = true;\r\n        pinchZoom = false;\r\n        initialX = e.touches[0].pageX;\r\n    }\r\n}\r\nfunction touchMove(e) {\r\n    e.preventDefault();\r\n    if (pinchZoom) {\r\n        const newX = e.touches[0].pageX - e.touches[1].pageX;\r\n        const deltaX = (initialX - newX) / 10;\r\n        scale = scale + deltaX;\r\n        scale = Math.min(100, scale);\r\n        scale = Math.max(1, scale);\r\n        wglp.gScaleX = 1 * Math.pow(scale, 1.5);\r\n        //log(diffX.toFixed(2));\r\n        initialX = newX;\r\n    }\r\n    if (drag) {\r\n        const newX = e.touches[0].pageX;\r\n        const deltaX = initialX - newX;\r\n        offset = offset - deltaX;\r\n        offset = Math.min(1000, offset);\r\n        offset = Math.max(-1000, offset);\r\n        wglp.gOffsetX = offset / 100;\r\n        initialX = newX;\r\n    }\r\n}\r\nfunction touchEnd(e) {\r\n    //\r\n    e.preventDefault();\r\n    pinchZoom = false;\r\n    drag = false;\r\n}\r\nfunction updateZoomRect(x1, x2) {\r\n    //\r\n}\r\nfunction doneResizing() {\r\n    //wglp.viewport(0, 0, canv.width, canv.height);\r\n}\r\nfunction createUI() {\r\n    const ui = document.getElementById(\"ui\");\r\n    display = document.createElement(\"p\");\r\n    display.innerHTML = \"helloðŸ˜‰\";\r\n    ui.appendChild(display);\r\n}\r\nfunction log(str) {\r\n    display.innerHTML = str;\r\n}\r\n//# sourceMappingURL=static.js.map\n\n//# sourceURL=webpack://webgl-plot-examples/./dist/static.js?");

/***/ }),

/***/ "./node_modules/webgl-plot/dist/webglplot.esm.js":
/*!*******************************************************!*\
  !*** ./node_modules/webgl-plot/dist/webglplot.esm.js ***!
  \*******************************************************/
/*! namespace exports */
/*! export ColorRGBA [provided] [no usage info] [missing usage info prevents renaming] */
/*! export WebglLine [provided] [no usage info] [missing usage info prevents renaming] */
/*! export WebglPolar [provided] [no usage info] [missing usage info prevents renaming] */
/*! export WebglStep [provided] [no usage info] [missing usage info prevents renaming] */
/*! export default [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__.r, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__,\n/* harmony export */   \"ColorRGBA\": () => /* binding */ ColorRGBA,\n/* harmony export */   \"WebglLine\": () => /* binding */ WebglLine,\n/* harmony export */   \"WebglPolar\": () => /* binding */ WebglPolar,\n/* harmony export */   \"WebglStep\": () => /* binding */ WebglStep\n/* harmony export */ });\nclass ColorRGBA {\r\n    constructor(r, g, b, a) {\r\n        this.r = r;\r\n        this.g = g;\r\n        this.b = b;\r\n        this.a = a;\r\n    }\r\n}\n\n/**\r\n * Baseline class\r\n */\r\nclass WebglBaseLine {\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor() {\r\n        this.scaleX = 1;\r\n        this.scaleY = 1;\r\n        this.offsetX = 0;\r\n        this.offsetY = 0;\r\n        this.loop = false;\r\n        this._vbuffer = 0;\r\n        this._prog = 0;\r\n        this._coord = 0;\r\n        this.visible = true;\r\n        this.intensity = 1;\r\n    }\r\n}\n\n/**\r\n * The standard Line class\r\n */\r\nclass WebglLine extends WebglBaseLine {\r\n    /**\r\n     * Create a new line\r\n     * @param c - the color of the line\r\n     * @param numPoints - number of data pints\r\n     * @example\r\n     * ```typescript\r\n     * x= [0,1]\r\n     * y= [1,2]\r\n     * line = new WebglLine( new ColorRGBA(0.1,0.1,0.1,1), 2);\r\n     * ```\r\n     */\r\n    constructor(c, numPoints) {\r\n        super();\r\n        this.webglNumPoints = numPoints;\r\n        this.numPoints = numPoints;\r\n        this.color = c;\r\n        this.xy = new Float32Array(2 * this.webglNumPoints);\r\n    }\r\n    /**\r\n     * Set the X value at a specific index\r\n     * @param index - the index of the data point\r\n     * @param x - the horizontal value of the data point\r\n     */\r\n    setX(index, x) {\r\n        this.xy[index * 2] = x;\r\n    }\r\n    /**\r\n     * Set the Y value at a specific index\r\n     * @param index : the index of the data point\r\n     * @param y : the vertical value of the data point\r\n     */\r\n    setY(index, y) {\r\n        this.xy[index * 2 + 1] = y;\r\n    }\r\n    /**\r\n     * Get an X value at a specific index\r\n     * @param index - the index of X\r\n     */\r\n    getX(index) {\r\n        return this.xy[index * 2];\r\n    }\r\n    /**\r\n     * Get an Y value at a specific index\r\n     * @param index - the index of Y\r\n     */\r\n    getY(index) {\r\n        return this.xy[index * 2 + 1];\r\n    }\r\n    /**\r\n     * Make an equally spaced array of X points\r\n     * @param start  - the start of the series\r\n     * @param stepSize - step size between each data point\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * //x = [-1, -0.8, -0.6, -0.4, -0.2, 0, 0.2, 0.4, 0.6, 0.8]\r\n     * const numX = 10;\r\n     * line.lineSpaceX(-1, 2 / numX);\r\n     * ```\r\n     */\r\n    lineSpaceX(start, stepSize) {\r\n        for (let i = 0; i < this.numPoints; i++) {\r\n            // set x to -num/2:1:+num/2\r\n            this.setX(i, start + stepSize * i);\r\n        }\r\n    }\r\n    /**\r\n     * Set a constant value for all Y values in the line\r\n     * @param c - constant value\r\n     */\r\n    constY(c) {\r\n        for (let i = 0; i < this.numPoints; i++) {\r\n            // set x to -num/2:1:+num/2\r\n            this.setY(i, c);\r\n        }\r\n    }\r\n    /**\r\n     * Add a new Y values to the end of current array and shift it, so that the total number of the pair remains the same\r\n     * @param data - the Y array\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * yArray = new Float32Array([3, 4, 5]);\r\n     * line.shiftAdd(yArray);\r\n     * ```\r\n     */\r\n    shiftAdd(data) {\r\n        const shiftSize = data.length;\r\n        for (let i = 0; i < this.numPoints - shiftSize; i++) {\r\n            this.setY(i, this.getY(i + shiftSize));\r\n        }\r\n        for (let i = 0; i < shiftSize; i++) {\r\n            this.setY(i + this.numPoints - shiftSize, data[i]);\r\n        }\r\n    }\r\n}\n\n/**\r\n * The step based line plot\r\n */\r\nclass WebglStep extends WebglBaseLine {\r\n    /**\r\n     * Create a new step line\r\n     * @param c - the color of the line\r\n     * @param numPoints - number of data pints\r\n     * @example\r\n     * ```typescript\r\n     * x= [0,1]\r\n     * y= [1,2]\r\n     * line = new WebglStep( new ColorRGBA(0.1,0.1,0.1,1), 2);\r\n     * ```\r\n     */\r\n    constructor(c, num) {\r\n        super();\r\n        this.webglNumPoints = num * 2;\r\n        this.numPoints = num;\r\n        this.color = c;\r\n        this.xy = new Float32Array(2 * this.webglNumPoints);\r\n    }\r\n    /**\r\n     * Set the Y value at a specific index\r\n     * @param index - the index of the data point\r\n     * @param y - the vertical value of the data point\r\n     */\r\n    setY(index, y) {\r\n        this.xy[index * 4 + 1] = y;\r\n        this.xy[index * 4 + 3] = y;\r\n    }\r\n    getX(index) {\r\n        return this.xy[index * 4];\r\n    }\r\n    /**\r\n     * Get an X value at a specific index\r\n     * @param index - the index of X\r\n     */\r\n    getY(index) {\r\n        return this.xy[index * 4 + 1];\r\n    }\r\n    /**\r\n     * Make an equally spaced array of X points\r\n     * @param start  - the start of the series\r\n     * @param stepSize - step size between each data point\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * //x = [-1, -0.8, -0.6, -0.4, -0.2, 0, 0.2, 0.4, 0.6, 0.8]\r\n     * const numX = 10;\r\n     * line.lineSpaceX(-1, 2 / numX);\r\n     * ```\r\n     */\r\n    lineSpaceX(start, stepsize) {\r\n        for (let i = 0; i < this.numPoints; i++) {\r\n            // set x to -num/2:1:+num/2\r\n            this.xy[i * 4] = start + i * stepsize;\r\n            this.xy[i * 4 + 2] = start + (i * stepsize + stepsize);\r\n        }\r\n    }\r\n    /**\r\n     * Set a constant value for all Y values in the line\r\n     * @param c - constant value\r\n     */\r\n    constY(c) {\r\n        for (let i = 0; i < this.numPoints; i++) {\r\n            // set x to -num/2:1:+num/2\r\n            this.setY(i, c);\r\n        }\r\n    }\r\n    /**\r\n     * Add a new Y values to the end of current array and shift it, so that the total number of the pair remains the same\r\n     * @param data - the Y array\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * yArray = new Float32Array([3, 4, 5]);\r\n     * line.shiftAdd(yArray);\r\n     * ```\r\n     */\r\n    shiftAdd(data) {\r\n        const shiftSize = data.length;\r\n        for (let i = 0; i < this.numPoints - shiftSize; i++) {\r\n            this.setY(i, this.getY(i + shiftSize));\r\n        }\r\n        for (let i = 0; i < shiftSize; i++) {\r\n            this.setY(i + this.numPoints - shiftSize, data[i]);\r\n        }\r\n    }\r\n}\n\nclass WebglPolar extends WebglBaseLine {\r\n    constructor(c, numPoints) {\r\n        super();\r\n        this.webglNumPoints = numPoints;\r\n        this.numPoints = numPoints;\r\n        this.color = c;\r\n        this.intenisty = 1;\r\n        this.xy = new Float32Array(2 * this.webglNumPoints);\r\n        this._vbuffer = 0;\r\n        this._prog = 0;\r\n        this._coord = 0;\r\n        this.visible = true;\r\n        this.offsetTheta = 0;\r\n    }\r\n    /**\r\n     * @param index: index of the line\r\n     * @param theta : angle in deg\r\n     * @param r : radius\r\n     */\r\n    setRtheta(index, theta, r) {\r\n        //const rA = Math.abs(r);\r\n        //const thetaA = theta % 360;\r\n        const x = r * Math.cos((2 * Math.PI * (theta + this.offsetTheta)) / 360);\r\n        const y = r * Math.sin((2 * Math.PI * (theta + this.offsetTheta)) / 360);\r\n        //const index = Math.round( ((theta % 360)/360) * this.numPoints );\r\n        this.setX(index, x);\r\n        this.setY(index, y);\r\n    }\r\n    getTheta(index) {\r\n        //return Math.tan\r\n        return 0;\r\n    }\r\n    getR(index) {\r\n        //return Math.tan\r\n        return Math.sqrt(Math.pow(this.getX(index), 2) + Math.pow(this.getY(index), 2));\r\n    }\r\n    setX(index, x) {\r\n        this.xy[index * 2] = x;\r\n    }\r\n    setY(index, y) {\r\n        this.xy[index * 2 + 1] = y;\r\n    }\r\n    getX(index) {\r\n        return this.xy[index * 2];\r\n    }\r\n    getY(index) {\r\n        return this.xy[index * 2 + 1];\r\n    }\r\n}\n\n/**\r\n * Author Danial Chitnis 2019\r\n *\r\n * inspired by:\r\n * https://codepen.io/AzazelN28\r\n * https://www.tutorialspoint.com/webgl/webgl_modes_of_drawing.htm\r\n */\r\n/**\r\n * The main class for the webgl-plot library\r\n */\r\nclass WebGLPlot {\r\n    /**\r\n     * Create a webgl-plot instance\r\n     * @param canvas - the canvas in which the plot appears\r\n     * @param debug - (Optional) log debug messages to console\r\n     *\r\n     * @example\r\n     *\r\n     * For HTMLCanvas\r\n     * ```typescript\r\n     * const canvas = dcoument.getEelementbyId(\"canvas\");\r\n     *\r\n     * const devicePixelRatio = window.devicePixelRatio || 1;\r\n     * canvas.width = canvas.clientWidth * devicePixelRatio;\r\n     * canvas.height = canvas.clientHeight * devicePixelRatio;\r\n     *\r\n     * const webglp = new WebGLplot(canvas);\r\n     * ...\r\n     * ```\r\n     * @example\r\n     *\r\n     * For OffScreenCanvas\r\n     * ```typescript\r\n     * const offscreen = htmlCanvas.transferControlToOffscreen();\r\n     *\r\n     * offscreen.width = htmlCanvas.clientWidth * window.devicePixelRatio;\r\n     * offscreen.height = htmlCanvas.clientHeight * window.devicePixelRatio;\r\n     *\r\n     * const worker = new Worker(\"offScreenCanvas.js\", { type: \"module\" });\r\n     * worker.postMessage({ canvas: offscreen }, [offscreen]);\r\n     * ```\r\n     * Then in offScreenCanvas.js\r\n     * ```typescript\r\n     * onmessage = function (evt) {\r\n     * const wglp = new WebGLplot(evt.data.canvas);\r\n     * ...\r\n     * }\r\n     * ```\r\n     */\r\n    constructor(canvas, debug) {\r\n        /**\r\n         * log debug output\r\n         */\r\n        this.debug = false;\r\n        this.debug = debug == undefined ? false : debug;\r\n        this.log(\"canvas type is: \" + canvas.constructor.name);\r\n        this.log(`[webgl-plot]:width=${canvas.width}, height=${canvas.height}`);\r\n        const webgl = canvas.getContext(\"webgl\", {\r\n            antialias: true,\r\n            transparent: false,\r\n        });\r\n        this.lines = [];\r\n        this.webgl = webgl;\r\n        this.gScaleX = 1;\r\n        this.gScaleY = 1;\r\n        this.gXYratio = 1;\r\n        this.gOffsetX = 0;\r\n        this.gOffsetY = 0;\r\n        // Enable the depth test\r\n        webgl.enable(webgl.DEPTH_TEST);\r\n        // Clear the color and depth buffer\r\n        webgl.clear(webgl.COLOR_BUFFER_BIT || webgl.DEPTH_BUFFER_BIT);\r\n        // Set the view port\r\n        webgl.viewport(0, 0, canvas.width, canvas.height);\r\n    }\r\n    /**\r\n     * updates and redraws the content of the plot\r\n     */\r\n    update() {\r\n        const webgl = this.webgl;\r\n        this.lines.forEach((line) => {\r\n            if (line.visible) {\r\n                webgl.useProgram(line._prog);\r\n                const uscale = webgl.getUniformLocation(line._prog, \"uscale\");\r\n                webgl.uniformMatrix2fv(uscale, false, new Float32Array([\r\n                    line.scaleX * this.gScaleX,\r\n                    0,\r\n                    0,\r\n                    line.scaleY * this.gScaleY * this.gXYratio,\r\n                ]));\r\n                const uoffset = webgl.getUniformLocation(line._prog, \"uoffset\");\r\n                webgl.uniform2fv(uoffset, new Float32Array([line.offsetX + this.gOffsetX, line.offsetY + this.gOffsetY]));\r\n                const uColor = webgl.getUniformLocation(line._prog, \"uColor\");\r\n                webgl.uniform4fv(uColor, [line.color.r, line.color.g, line.color.b, line.color.a]);\r\n                webgl.bufferData(webgl.ARRAY_BUFFER, line.xy, webgl.STREAM_DRAW);\r\n                webgl.drawArrays(line.loop ? webgl.LINE_LOOP : webgl.LINE_STRIP, 0, line.webglNumPoints);\r\n            }\r\n        });\r\n    }\r\n    clear() {\r\n        // Clear the canvas  //??????????????????\r\n        //this.webgl.clearColor(0.1, 0.1, 0.1, 1.0);\r\n        this.webgl.clear(this.webgl.COLOR_BUFFER_BIT || this.webgl.DEPTH_BUFFER_BIT);\r\n    }\r\n    /**\r\n     * adds a line to the plot\r\n     * @param line - this could be any of line, linestep, histogram, or polar\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const line = new line(color, numPoints);\r\n     * wglp.addLine(line);\r\n     * ```\r\n     */\r\n    addLine(line) {\r\n        line._vbuffer = this.webgl.createBuffer();\r\n        this.webgl.bindBuffer(this.webgl.ARRAY_BUFFER, line._vbuffer);\r\n        this.webgl.bufferData(this.webgl.ARRAY_BUFFER, line.xy, this.webgl.STREAM_DRAW);\r\n        const vertCode = `\r\n      attribute vec2 coordinates;\r\n      uniform mat2 uscale;\r\n      uniform vec2 uoffset;\r\n\r\n      void main(void) {\r\n         gl_Position = vec4(uscale*coordinates + uoffset, 0.0, 1.0);\r\n      }`;\r\n        // Create a vertex shader object\r\n        const vertShader = this.webgl.createShader(this.webgl.VERTEX_SHADER);\r\n        // Attach vertex shader source code\r\n        this.webgl.shaderSource(vertShader, vertCode);\r\n        // Compile the vertex shader\r\n        this.webgl.compileShader(vertShader);\r\n        // Fragment shader source code\r\n        const fragCode = `\r\n         precision mediump float;\r\n         uniform highp vec4 uColor;\r\n         void main(void) {\r\n            gl_FragColor =  uColor;\r\n         }`;\r\n        const fragShader = this.webgl.createShader(this.webgl.FRAGMENT_SHADER);\r\n        this.webgl.shaderSource(fragShader, fragCode);\r\n        this.webgl.compileShader(fragShader);\r\n        line._prog = this.webgl.createProgram();\r\n        this.webgl.attachShader(line._prog, vertShader);\r\n        this.webgl.attachShader(line._prog, fragShader);\r\n        this.webgl.linkProgram(line._prog);\r\n        this.webgl.bindBuffer(this.webgl.ARRAY_BUFFER, line._vbuffer);\r\n        line._coord = this.webgl.getAttribLocation(line._prog, \"coordinates\");\r\n        this.webgl.vertexAttribPointer(line._coord, 2, this.webgl.FLOAT, false, 0, 0);\r\n        this.webgl.enableVertexAttribArray(line._coord);\r\n        this.lines.push(line);\r\n    }\r\n    /**\r\n     * remove the last line\r\n     */\r\n    popLine() {\r\n        this.lines.pop();\r\n    }\r\n    /**\r\n     * Change the WbGL viewport\r\n     * @param a\r\n     * @param b\r\n     * @param c\r\n     * @param d\r\n     */\r\n    viewport(a, b, c, d) {\r\n        this.webgl.viewport(a, b, c, d);\r\n    }\r\n    log(str) {\r\n        if (this.debug) {\r\n            console.log(\"[webgl-plot]:\" + str);\r\n        }\r\n    }\r\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WebGLPlot);\n\n\n\n//# sourceURL=webpack://webgl-plot-examples/./node_modules/webgl-plot/dist/webglplot.esm.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	__webpack_require__("./dist/static.js");
/******/ 	// This entry module used 'exports' so it can't be inlined
/******/ })()
;